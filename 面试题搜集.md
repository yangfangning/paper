
# 面试题

## 1，解释一下多态

多态分为动态绑定和静态绑定
静态绑定就是函数的重载
动态绑定是考的基类指针指向子类对象，和虚函数结合。
是面向对象编程中的一个概念，它允许同样的函数接口在不同的对象上表现出不同的行为。C++ 中实现多态性主要依靠虚函数（virtual functions）和动态绑定。

虚函数是在基类中声明并用 `virtual` 关键字进行标记的成员函数。派生类可以覆盖该虚函数，并根据需要提供自己的实现。通过使用指向基类对象的指针或引用调用虚函数时，程序将根据运行时实际对象类型来确定要调用的函数。

## 2 dynamic_cast的实现原理


能将基类的指针或引用安全的转换为派生类的指针或引用，转换失败返回空指针。

将基类指向子类的指针，转换为子类指向子类
使用条件，基类必须有虚函数
原理是基类和子类都有虚函数表，两者不同，当使用基类指向子类时，基类指针的虚函数指针，指向的是子类的虚函数表，所以可以转换，多态的原理也是如此，每个类中有虚函数的时候，一个类会有一个共有的虚函数表，当继承的时候，会复制一个父类的虚函数表，当用父类指针指向子类时，指向的是子类的虚函数表。

dynamic_cast是安全的，他不允许父类指向父类对象的指针，转换子类指针，因为这样，原本的指针不能访问到子类中的数据，但转换完后，就可以访问到了，不安全。

如果想转换成功使用**static_cast**(可以实现各种类型的转换)这个可以转换成功。

# 3，function lambda bind的区别和联系

function是一个类模版
抽象了函数的参数以及函数返回值的类型，是动态绑定，只需要修改对象就能实现多态


lambda是一个表达式，一种方便创建匿名函数的语法糖。

bind是一个函数适配器，用来通过绑定函数和函数参数的方式声明函数对象的函数模版，还可以提供占位符，来灵活使用参数。

# 4.vector怎么删除重复的元素

1、Vector去除重复元素
Vector(int) v1;
sort(v1.begin(),v1.end());
v1.earse(unique(v1.begin(),v1.end),v1.end());
2、 unique函数可以删除有序数组中的重复元素。
包含的头文件 /#include
注意：
a 这里的删除不是真的delete，而是将重复的元素放到容器末尾
b unique函数的返回值是去重之后的尾地址
c 一定要先对数组进行排序才可以使用unique函数

原理：从前往后遍历，当发现第一次发现一个数时，将其赋值到前面，使用双指针实现，当遍历到末尾时，退出，返回前一个指针。
例子11223345，会变为12345345，其中后面的345，是只读操作。

时间复杂度，排序是logn，unique是n，所以最后是nlogn
# 5.vector的删除元素的时间复杂度，在不考虑删除后顺序的情况下如何最快效率的删除。

earse的时间复杂度为n，删除最后一个元素为1.
不考虑顺序的话，将最后一项的元素，替换，删除元素为值，然后把最后一项删了。

# 6.stl的hashmap实现原理

STL中的`hash_map`是一种基于哈希表的关联容器，它允许我们根据键值快速查找、插入和删除元素。以下是`hash_map`实现的基本原理：

1. 哈希函数：一个哈希函数将键值映射到特定的索引。不同的键值可能映射到相同的索引，这就是所谓的“冲突”。
    
2. 哈希表：一个哈希表是一个数组，数组中的每个元素都是一个桶（bucket），桶可以是单向链表或红黑树（取决于桶中元素的数量）。
    
3. 装填因子：哈希表中元素的数量和桶的数量的比值称为装填因子。
    
4. 扩容：当装填因子达到某个阈值时，哈希表会动态地增加桶的数量，这个过程称为“扩容”。
    
5. 冲突解决：当两个不同的键值映射到相同的索引时，使用特定的冲突解决方法，如开放定址法、再哈希法、链地址法（用链表连接相同哈希值的元素）等。

# 7.map的实现，插入和查询的时间复杂度

是使用红黑树实现的，插入查询，复杂度都是logn

# 8.红黑树和hashmap各适用于什么情况。

红黑树适用于需要进行范围查询、频繁插入和删除、且数据量大的情况。它能保持数据的有序性，并且在最坏情况下的操作时间复杂度为O(log n)。

Hashmap适用于键值查找场景，特别是在键是唯一的情况下。它能提供常数时间复杂度的查找、插入和删除操作。然而，它不保持数据的顺序性，并且在最坏情况下的操作时间复杂度为O(n)。

# 9.查询较多时，有序vector和红黑树怎么选择

分情况，当通过下标查询时，选择有序vector，当使用find函数来查时，复杂度为n，选择红黑树，当自定义查询方法时，两者的查询复杂度相同，选择有序vector，占用内存小。

# 10.Linux锁的种类

linux锁的种类：
1. mutex（互斥锁），用于保证在任何时刻，都只能有一个线程访问该对象；
2. rwlock（读写锁），分为读锁和写锁，适用于读取数据的频率远远大于写数据的频率的场合；
3. spinlock（自旋锁），在任何时刻同样只能有一个线程访问对象；
4. seqlock（顺序锁），用于能够区分读与写的场合，并且是读操作很多、写操作很少，写操作的优先权大于读操作。
5. semaphore(信号量)，可以控制多个线程对共享资源的访问。获取是将信号量加一，释放时将信号量减一。

# 11.Linux线程并发时，如何改进锁的使用，减少开销

如果可行的话，使用轻量级锁，当线程在大多是不会竞争锁的时候
控制锁的粒度
控制锁的顺序

# 12，静态库和动态库的区别

静态库每个程序调用时都会在内存中创建一份，而动态库是运行时才载入，只存在一份。动态库还可以解决更新问题，当库更新时，如果是静态库，则要全部重新编译，而动态库只需要增量更新

动态库和静态库各有优缺点，适用于不同的应用场景。以下是它们的主要优缺点：

## 动态库

### 优点

1. **节省内存和磁盘空间**：动态库可以被多个应用程序共享，从而减少了内存和磁盘空间的使用。
2. **方便更新和维护**：更新动态库不需要重新编译和链接所有使用该库的应用程序，只需替换旧的动态库文件即可。
3. **减少可执行文件的大小**：动态链接的程序体积较小，因为库函数并没有包含在可执行文件中。
4. **灵活性高**：允许在运行时加载和卸载库，提高了程序的灵活性和可扩展性。

### 缺点

1. **加载时间**：在程序启动时需要加载动态库，可能会增加启动时间。
2. **运行时依赖性**：需要在运行时找到并加载正确版本的动态库，库版本不匹配可能导致程序运行错误。
3. **性能开销**：由于需要在运行时解析符号，调用动态库函数比静态库函数稍慢。

## 静态库

### 优点

1. **独立性强**：静态库在编译时被打包到可执行文件中，运行时不需要依赖外部库，适合于部署环境复杂的场景。
2. **加载速度快**：无需在运行时加载库文件，程序启动速度更快。
3. **版本控制简单**：不必担心库的版本兼容问题，因为库已经打包到应用程序中。

### 缺点

1. **占用更多空间**：每个使用静态库的程序都会包含一份库的副本，增加了磁盘空间和内存的占用。
2. **更新麻烦**：更新静态库需要重新编译和链接所有使用该库的应用程序。
3. **可执行文件体积大**：由于库函数包含在可执行文件中，导致文件体积较大。

## 适用场景

- **动态库**：适用于需要共享库的多个程序或需要频繁更新库的场景，如操作系统的标准库、第三方库等。
- **静态库**：适用于部署环境复杂、需要独立运行的程序，如嵌入式系统、独立发行的软件等。


# c++中的动态数组和静态数组

==**[动态数组__](https://m.baidu.com/s?word=%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84&sa=re_dqa_zy)和静态数组的主要区别在于它们的内存管理方式、大小的可变性以及如何通过函数返回。**==12

- ==**内存管理方式**==：静态数组在内存中位于栈区，其大小在编译期间就确定并分配，使用结束后由计算机自动释放，效率较高。而动态数组位于堆区，其大小是在运行时给定并且可以改变，使用结束后需要程序员手动释放，效率相对较低。
    
- ==**大小的可变性**==：静态数组的大小是固定的，在程序运行过程中无法改变其大小。这限制了静态数组在需要动态添加数据时的应用。相比之下，动态数组可以在程序运行时根据需要动态地调整其大小，这使得动态数组在处理不确定数量的数据时更加灵活。
    
- ==**通过函数返回**==：在函数内部声明的静态数组不可能通过函数返回，因为函数调用完成后其内部变量占用的内存会被自动释放。如果需要通过函数返回一个数组，可以在函数中用`new`动态创建该数组，然后返回其首地址。这样，即使函数结束，动态数组所占用的内存也不会被自动释放，直到程序员手动释放它。
    

此外，静态数组和动态数组在`sizeof`运算时的表现也有所不同。对于静态数组，`sizeof`运算的结果是整个数组的大小，而对于动态数组，`sizeof`运算的结果可能只反映数组的第一个元素的大小或常数大小，具体取决于如何使用`sizeof`。

综上所述，选择静态数组还是动态数组取决于具体的应用场景和需求。静态数组适合那些数据量固定且不需要在程序运行过程中改变大小的场景，而动态数组则更适合需要灵活处理不确定数量数据的情况。


算法题，给定一个无序数组，从中找出第三大的数（里面的数可重复）

杀死内存占有最大的线程的命令
kill 

分布式引擎

从cpp文件到可执行文件的过程
预处理，编译，汇编，链接
死锁预防算法
no_wait ，wound-wait
机器学习相关：
对数据进行了那些处理
计算过程

12.Linux线程通信和同步

13.熟不熟悉图形学。（不熟悉）

14.C++11的新特性了解吗

  
  
# 数据结构
## 1，红黑树
是一种平衡二叉树，复杂度是logn
节点只有红黑两色，所有叶子节点都是黑色（空也算），每个节点到叶子节点的路径上的黑色节点数量一致，红色节点后必须是黑的节点，根节点必须是黑色

插入麻烦，删除更麻烦[[[图解“红黑树”原理，一看就明白！ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/269576465)]]