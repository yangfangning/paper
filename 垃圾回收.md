# 1，简介
本文介绍的 OneShotGC 是一种全新的多版本存储设计，它消除了垃圾回收过程中的版本遍历，并将发现和内存管理开销降至最低。OneShotGC 利用各版本之间的时间相关性，将它们适时地聚类到可一次性释放的连续内存块中。我们在 Proteus 中实现了 OneShotGC，并使用 YCSB 和 TPC-C 对其性能进行了实验性评估，结果表明与最先进的技术相比，OneShotGC 的事务吞吐量提高了 2 倍。

现代内存在线事务处理（OLTP）引擎可并行执行多个事务，以利用扩展服务器中不断增加的 CPU 内核和主内存。由于并发运行的事务可能会导致数据访问冲突，因此 OLTP 引擎需要提供数据一致性保证。目前，大多数引擎（如 Oracle、MySQL、Microsoft SQL Server、PostgreSQL 和 SAP HANA）都提供快照隔离（SI）保证：SI 允许提高并发性，同时防止大多数异常情况，并提供良好的可扩展性，使 OLTP 引擎能够利用 CPU 的并行性。
现有方法通过主动或被动的垃圾回收（GC）来频繁收集无法访问的版本，从而减少多版本化的开销。当没有事务能在任何时间点访问这些版本时，这些版本就会变得不可访问。具体来说，在一条记录的最新版本之前创建的所有版本，只要能被系统中当前活动的最近事务访问，都是不可访问的，因此可以被丢弃。主动式方法 [2, 5, 18] 将垃圾回收阶段放在每个事务的末尾或执行过程中。在主动垃圾回收期间，OLTP 引擎会遍历版本链，查找并释放无法访问的版本。但是，版本链遍历会产生对版本列表的随机访问，因此不会随版本链长度的增加而增加。在主动 GC 中，版本链长度取决于工作负载的写入率，因为每次写入都会向版本链添加一个新版本。被动式方法 [1, 13] 将无法访问的版本注册到一个后台进程，该进程会定期将其清空。在被动式 GC 中，链的长度取决于工作负载的写入率和真空进程的频率。遗憾的是，吸尘频率很难确定：如果吸尘频率过高，会影响事务执行；如果吸尘频率过低，又会导致版本链过长。无论哪种情况，性能都会下降，如何取舍在很大程度上取决于实时工作负载参数。

我们设计了一种版本存储设计，可根据版本的时间属性对其进行物理分区，并允许透明的跨分区版本遍历。- 我们提出了一种垃圾回收算法 OneShotGC，它可以消除 GC 过程中的版本遍历，在不需要每个版本链接更新的情况下进行版本整合，并实现分区级链整合。- 我们在一个内存 OLTP 引擎中实现了我们的方法，并通过实验展示了 OneShotGC 如何将事务吞吐量提高到最新技术的 2 倍。此外，我们还展示了不同的事务性工作负载会放大 OneShotGC 所取得的收益。
