取值与取址符
比如int * P = a；
P是指针，想获取P所指向的值要用\*P来获取。
想获取一个数据的地址，就是&符号。
# 1，程序的内存模型
C++程序在执行时，将内存大方向划分为**4个区域**

- 代码区：存放函数体的二进制代码，由操作系统进行管理的
    
- 全局区：存放全局变量和静态变量以及常量
    
- 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等
    
- 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收

**代码区**
对于c++来说，代码编译完之后会有.exe文件。这样的文件在执行前就有**代码区**。对于其他语言有的不会有exe文件，比如python。代码区存放的是代码的二进制样式，是共享且只读的，当运行程序(点击exe文件)时就会访问这个代码区执行，多次执行会访问同一个代码区文件，所以是共享的，而且不能作出修改所以是只读的。

**全局区**
这里存放全局变量和静态变量(static int定义的)，全局区还包含常量区，字符串常量和其他常量。

该区域的数据在程序结束后由操作系统释放

总结：

- C++中在程序运行前分为全局区和代码区
    
- 代码区特点是共享和只读
    
- 全局区中存放全局变量、静态变量、常量
    
- 常量区中存放 const修饰的全局常量 和 字符串常量

**栈区：**

由编译器自动分配释放, 存放**函数的参数值,局部变量**等

注意事项：**不要返回局部变量的地址**，栈区开辟的数据由编译器自动释放，再次访问时可能已经被释放了。

**堆区：**

由程序员分配释放,若程序员不释放,程序结束时由操作系统回收

在C++中主要利用**new在堆区开辟内存**

释放堆区使用delete，释放数组时使用delete[]

# 2，引用

### 2.1 引用的基本使用

**作用：** 给变量起别名

**语法：** `数据类型 &别名 = 原名`
### 2.2 引用注意事项

- 引用必须初始化
    
- 引用在初始化后，不可以改变(更改引用是指原本是b是a的别名，现在让b是c的别名是不行的，但是可以通过其赋新的值)
### 2.3 引用做函数参数

**作用** : 函数传参时，可以利用引用的技术让形参修饰实参

**优点** : 可以简化指针修改实参(指针还需要取值，解引用等操作)
### 2.4 引用做函数返回值

作用：引用是可以作为函数的返回值存在的

注意：**不要返回局部变量的引用**

用法：函数调用作为左值(一个函数的返回值为引用时，可以当做等式的左值使用，当做常量来使用，来给这个引用进行赋值)

引用的本质是一个指针常量(int * const，指针指向的地方不可改变，但是指向的内存的内容可以更改)

const修饰指针有三种情况

1. const修饰指针 --- 常量指针
    
2. const修饰常量 --- 指针常量
    
3. const即修饰指针，又修饰常量
### 2.6 常量引用

**作用**：常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加==const修饰形参==，防止形参改变实参(使用const修饰引用的形参时，相当一const的第三种情况，这样既不能修改指向哪，也不能修改指向的值)
值传递也能实现相同的目标，但是这样会多占用内存。

# 3 函数提高

## 3.1 函数默认参数

在C++中，函数的形参列表中的形参是可以有默认值的。

语法：返回值类型 函数名 （参数= 默认值）{}
当函数已经有默认值时，在调用函数时，不输入的话，也能调用。当有默认值也输入的时候，使用的是输入的值。
//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值
//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数(函数的声明是指一个函数可以先声明，里面无实现方法，在后面再写一个函数实现。相同的名字。但是函数的声明和函数的实现只有只有一个有默认值，否则编译器不知道使用哪个的默认值来进行实现)
## 3.2 函数占位参数

C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须把这个占位的参数进行赋值，不能不赋值，还可以在函数里进行初始化。

**语法：** `返回值类型 函数名 (数据类型){}`

在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术
## 3.3 函数重载

### 3.3.1 函数重载概述

**作用：**函数名可以相同，提高复用性

**函数重载满足条件：**

- 同一个作用域下
    
- 函数名称相同
    
- 函数参数**类型不同** 或者 **个数不同** 或者 **顺序不同**
    
**注意:** 函数的返回值不可以作为函数重载的条件(返回值不同不能当做函数重载)
### 3.3.2 函数重载注意事项

- 引用作为重载条件(当使用引用为参数时，对于const和无const修饰，当函数的调用时直接使用数值时，会使用有const的函数)
    
- 函数重载碰到函数默认参数(函数重载使用默认参数时，当两个函数的调用相同时，会有歧义，需要避免)
# **4** 类和对象

C++面向对象的三大特性为：==封装、继承、多态==

C++认为==万事万物都皆为对象==，对象上有其属性和行为
## 4.1 封装

### 4.1.1 封装的意义

封装是C++面向对象三大特性之一

封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物
    
- 将属性和行为加以权限控制

**封装意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

1. public 公共权限(类内可以访问  类外可以访问)
    
2. protected 保护权限(类内可以访问  类外不可以访问)
    
3. private 私有权限(类内可以访问  类外不可以访问)
**protected和private的区别在于继承，private子类不可访问，protected子类可以访问**
### 4.1.2 struct和class区别

在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**

区别：

- struct 默认权限为公共
    
- class 默认权限为私有
### 4.1.3 成员属性设置为私有

**优点1** ：将所有成员属性设置为私有，可以自己控制读写权限

**优点2** ：对于写权限，我们可以检测数据的有效性

## 4.2 对象的初始化和清理

- 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
    
- C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。
    

### 4.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

一个对象或者变量没有初始状态，对其使用后果是未知

同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

c++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**

**编译器提供的构造函数和析构函数是空实现。**

- 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
    
- 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。
    

**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
    
2. 函数名称与类名相同
    
3. 构造函数可以有参数，因此可以发生重载(当自己实现了有参构造时，不会调用默认的无参构造，所以一般会自己在实现一个无参构造)
    
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次
    

**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
    
2. 函数名称与类名相同,在名称前加上符号 ~
    
3. 析构函数不可以有参数，因此不可以发生重载
    
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次
### 4.2.2 构造函数的分类及调用

两种分类方式：

按参数分为： 有参构造和无参构造

按类型分为： 普通构造和拷贝构造

三种调用方式：

**括号法**(调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明，不会创建对象)：括号里可以写值也可以使用拷贝构造。方式为类名 对象()   例如 Person p1(10); 这里不能

**显示法**:方式为类名 对象 = 类名(值） 例如 Person p1 = Person(10);
Person(10)单独写就是**匿名对象**  当前行结束之后，马上析构
不能利用 拷贝构造函数 初始化**匿名对象** 编译器认为是对象声明。例如：Person(p4); 这样不是创建一个匿名对象，而是会认为声明了对象p4。而对象p4已经存在，所以出错。

**隐式转换法**：编译器会默认改为显示法
Person p4 = 10; // Person p4 = Person(10); 
Person p5 = p4; // Person p5 = Person(p4);

拷贝构造如下所示：这里之所以使用引用传递而不是值传递，是因为值传递会创建一个新的副本，新的副本会调用构造函数，然后再执行一次拷贝构造无限递归。所以不使用值传递，使用const修饰的原因是为了能够引用常量，。
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
### 4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况

- 使用一个已经创建完毕的对象来初始化一个新对象
    
- 值传递的方式给函数参数传值（值传递相当于创建了一个新的副本，当函数参数为对象值时，传入时会进行拷贝构造，拷贝出一个新的对象用来操作）
    
- 以值方式返回局部对象（当以值的方式返回一个对象时，由于局部参数在函数使用完后，会立即释放，所以返回的并不是局部参数，而是返回的一个新的对象，此时就会使用拷贝构造）
### 4.2.4 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1．默认构造函数(无参，函数体为空)

2．默认析构函数(无参，函数体为空)

3．默认拷贝构造函数，对属性进行值拷贝(浅拷贝)

构造函数调用规则如下：

- 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造
    
- 如果用户定义拷贝构造函数，c++不会再提供其他构造函数
### 4.2.5 深拷贝与浅拷贝

深浅拷贝是面试经典问题，也是常见的一个坑

对象里定义的变量属于栈区，也可以存在new创建在堆区变量，这里存的是指针是地址。

浅拷贝：简单的赋值拷贝操作(只会将栈区的变量进行拷贝，对于堆区中的变量也会复制过来，但是这两者会指向同一内存，这样，当一个对象释放后，另一个对象释放，会出现堆区内存重复释放)

深拷贝：在堆区重新申请空间，进行拷贝操作(深拷贝就是在堆区重新创建内存，然后拷贝，指向新的内存)
### 4.2.6 初始化列表

**作用：**

C++提供了初始化列表语法，用来初始化属性

**语法：`构造函数()：属性1(值1),属性2（值2）... {}`

上述语法可以，但不够灵活，可以写成这样Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) {}；

### 4.2.7 类对象作为类成员

C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员

对于对象成员的构造与析构函数调用顺序，是对象成员的构造先调用，然后调用本类构造。析构与之相反，相当于栈先进后出

### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员，放到全局区了

静态成员分为：

- 静态成员变量
    
    - 所有对象共享同一份数据
        
    - 在编译阶段分配内存
        
    - **类内声明，类外初始化**
        
- 静态成员函数
    
    - 所有对象共享同一个函数
        
    - **静态成员函数只能访问静态成员变量**

静态成员有两种访问方式，可以通过对象或者类名加::来访问静态成员。而且其有访问权限。

## 4.3 C++对象模型和this指针

成员函数类外实现可以使用 **返回类型 类名::成员函数** 来实现，但是函数类中要有声明。当是构造函数时，不需要写返回类型。

### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上(也就是说只有非静态成员变量才占类的内存，才属于类的对象)

空对象占有内存为1，目的是为了区分空对象占内存的位置

### 4.3.2 this指针概念

通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？

c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**

this指针是隐含每一个非静态成员函数内的一种指针(对于静态成员函数就没有this指针了，因为他是共享的)

this指针不需要定义，直接使用即可

this指针的用途：

- 当形参和成员变量同名时，可用this指针来区分
    
- 在类的非静态成员函数中返回对象本身，可使用return *this

###   4.3.3 空指针访问成员函数

C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针

如果用到this指针，需要加以判断保证代码的健壮性

### 4.3.4 const修饰成员函数

**常函数：**

- 成员函数**后**加const后我们称为这个函数为**常函数**
    
- 常函数内不可以修改成员属性
    
- 成员属性声明时加关键字**mutable**后，在常函数中依然可以修改
    

**常对象：**

- 声明对象前加const称该对象为常对象
    
- 常对象只能调用常函数

## 4.4 友元

生活中你的家有客厅(Public)，有你的卧室(Private)

客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去

但是呢，你也可以允许你的好闺蜜好基友进去。

在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术

友元的目的就是让一个函数或者类 访问另一个类中私有成员

友元的关键字为 ==friend==

友元的三种实现

- 全局函数做友元(在类里声明一下全局函数，并在其前面加friend，调用此全局函数就可以访问类里的私有属性)
    
- 类做友元(在a类里加 friend class b类名;  这样b类就可以调用a类中的私有成员)
    
- 成员函数做友元(在a类里加 friend 函数名(这里的函数名需要写成b类名::函数名的形式);  这样b类中的指定函数就可以调用a类中的私有成员)

## 4.5 运算符重载

运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型

相当于自己实现对应的函数，但是函数名都一样了，是operator运算符，这样就可以将对应的运算符重载。而且这个函数还可以发生重载。

### 4.5.1 加号运算符重载

作用：实现两个自定义数据类型相加的运算
自己实现的函数可以是成员函数，也可以是全局函数
成员函数的本质是使用加号前面的对象调用operator+函数
全局函数的本质是调用全局函数，参数为相加的两者。
> 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的(比如两个int类型的相加，是不可以改变的，不能实现1+1变成1-1的结果。只能重载自定义的数据类型)

> 总结2：不要滥用运算符重载

#### 4.5.2 左移运算符重载

作用：可以输出自定义数据类型
只能是全局函数，不能是成员函数，当是成员函数时，需要输入cout，但这样简化后成p<\<cout。这样就不是想要的结果，不是左移运算符了。为什么需要输入cout呢，是因为当输入类时，本质是此对象调用该对象中的方法，输入的是此此对象，所以不能实现，只有一个对象，无法实现两个对象。
ostream全局只有一个所以要用引用。
当使用cout << p1后再想输入回车时可能会出错，之前可以连着输出是因为链式编程的原因，cout<\<p1后必须是cout类型的才可以链式编程。

一般成员变量是私有的，当全局函数想访问私有的成员变量可以使用友元的技术，不使用友元时，就太麻烦了，还需要在类里实现调用私有属性，然后在全局函数中调用类里的方法。

### 4.5.3 递增运算符重载

作用： 通过重载递增运算符，实现自己的整型数据
> 总结： **前置递增返回引用，后置递增返回值**（因为后置递增返回的是局部变量，不能返回局部变量的地址）

使用后置++时，需要使用int来当占位符，所以重载时需要输入的参数为int，但是实际不输入。而且必须是int

### 4.5.4 赋值运算符重载

c++编译器至少给一个类添加4个函数

1. 默认构造函数(无参，函数体为空)
    
2. 默认析构函数(无参，函数体为空)
    
3. 默认拷贝构造函数，对属性进行值拷贝
    
4. 赋值运算符 operator=, 对属性进行值拷贝
    

如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题

### 4.5.5 关系运算符重载

**作用：重载关系运算符，可以让两个自定义类型对象进行对比操作

### 4.5.6 函数调用运算符重载

- 函数调用运算符 () 也可以重载
    
- 由于重载后使用的方式非常像函数的调用，因此称为仿函数
    
- 仿函数没有固定写法，非常灵活
可以直接对象名加()来调用重载函数的内容

可用于匿名函数调用，匿名函数是类名加()来表示匿名对象，然后在加个(),这个里面加参数。

## 4.6 继承

**继承是面向对象三大特性之一**

有些类与类之间存在特殊的关系，例如下图中：

![1544861202252](file://E:\%E6%A1%8C%E9%9D%A2\%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\%E5%8C%A0%E5%BF%83%E7%B2%BE%E4%BD%9CC++%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B-%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E4%B8%8D%E5%86%8D%E9%9A%BE%E8%B5%84%E6%96%99\%E7%AC%AC3%E9%98%B6%E6%AE%B5-C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%20%E8%B5%84%E6%96%99\%E8%AE%B2%E4%B9%89\assets\1544861202252.png?lastModify=1714567661)

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。

这个时候我们就可以考虑利用继承的技术，减少重复代码

### 4.6.1 继承的基本语法

例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同
class 子类名 : public 父类名

**总结：**

继承的好处：==可以减少重复的代码==

class A : public B;

A 类称为子类 或 派生类

B 类称为父类 或 基类

**派生类中的成员，包含两大部分**：

一类是从基类继承过来的，一类是自己增加的成员。

从基类继承过来的表现其共性，而新增的成员体现了其个性。

### 4.6.2 继承方式

继承的语法：`class 子类 : 继承方式 父类`

**继承方式一共有三种：**

- 公共继承
    
- 保护继承
    
- 私有继承
![[Pasted image 20240501212128.png]]

父类中的私有成员，无论什么继承都不能访问，
公共继承对于父类中的公共属性到子类中依然是公共权限，保护权限依旧是保护权限
保护继承对于父类中的公共属性和保护属性到子类中都变为保护权限
私有继承对于父类中的公共属性和保护权限都变为私有权限

### 4.6.3 继承中的对象模型

**问题**：从父类继承过来的成员，哪些属于子类对象中？

结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到

### 4.6.4 继承中构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数
总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反
### 4.6.5 继承同名成员处理方式

问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

	//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数
	//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域

- 访问子类同名成员 直接访问即可
    
- 访问父类同名成员 需要加作用域

### 4.6.6 继承同名静态成员处理方式

问题：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致

- 访问子类同名成员 直接访问即可
    
- 访问父类同名成员 需要加作用域
总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）

### 4.6.7 多继承语法

C++允许**一个类继承多个类**

语法：`class 子类 ：继承方式 父类1 ， 继承方式 父类2...`

多继承可能会引发父类中有同名成员出现，需要加作用域区分

**C++实际开发中不建议用多继承**

总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域

### 4.6.8 菱形继承

**菱形继承概念：**

两个派生类继承同一个基类

又有某个类同时继承者两个派生类

这种继承被称为菱形继承，或者钻石继承

**菱形继承问题**

1. 羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。
    
2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。

总结：

- 菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
    
- 利用虚继承可以解决菱形继承问题：

//继承前加virtual关键字后，变为虚继承
//此时公共的父类Animal称为虚基类
例如：
class Sheep : virtual public Animal {};
class Tuo   : virtual public Animal {};
class SheepTuo : public Sheep, public Tuo {};

虚继承继承的是虚基类指针，指针指向同一个虚基类表，记录了偏移量，指向同一位置。

## 4.7 多态

//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护

前提知识：虚函数里面存的是指针，指向vbtable，指针占四字节
当子类重写了父类的虚函数，会覆盖虚函数的指针指向的内容，变为重写的函数

当父类指针或者引用指向子类时，调用时就会首先调用子类中重写的函数。当没重写时，就说明没有被覆盖，就会调用父类的虚函数

### 4.7.1 多态的基本概念

**多态是C++面向对象三大特性之一**

多态分为两类

- 静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名
    
- 动态多态: 派生类和虚函数实现运行时多态
    

静态多态和动态多态区别：

- 静态多态的函数地址早绑定 - 编译阶段确定函数地址
    
- 动态多态的函数地址晚绑定 - 运行阶段确定函数地址

虚函数会将函数的地址晚点确定，当调用时才会确定地址

动态多态总结：

动态多态满足条件

- 有继承关系
    
- 子类**重写**父类中的虚函数
    

动态多态使用条件

- 父类指针或引用指向子类对象(例如函数的参数时父类的指针或者引用，但是输入的是子类，这样父类指针或引用就会指向子类对象)
    

**重写：函数返回值类型 函数名 参数列表 完全一致称为重写**

### 4.7.3 纯虚函数和抽象类

在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容

因此可以将虚函数改为**纯虚函数**

纯虚函数语法：`virtual 返回值类型 函数名 （参数列表）= 0 ;`

当类中有了纯虚函数，这个类也称为==抽象类==

**抽象类特点**：

- 无法实例化对象
    
- 子类必须重写抽象类中的纯虚函数，否则也属于抽象类

#### 4.7.5 虚析构和纯虚析构

多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码

意思就是，当子类中有堆区中的数据时，析构时，**父类指针无法调用子类的析构代码**，只能调用父类的析构代码，这样就造成了内存泄漏，可以通过把析构函数变为虚函数或者纯虚函数，来通过父类指针来调用子类析构函数，来释放堆区的内存。

解决方式：将父类中的析构函数改为**虚析构**或者**纯虚析构**

虚析构和纯虚析构共性：

- 可以解决父类指针释放子类对象
    
- **都需要有具体的函数实现**(当时纯虚析构时也需要实现这个虚析构函数，不实现的话，会报错)
    

**虚析构和纯虚析构区别**：

- 如果是纯虚析构，该类属于抽象类，无法实例化对象
    

虚析构语法：

`virtual ~类名(){}`

纯虚析构语法：

`virtual ~类名() = 0;`

`类名::~类名(){}`

总结：

1. 虚析构或纯虚析构就是用来**解决通过父类指针释放子类对象**

2. **如果子类中没有堆区数据，可以不写为虚析构或纯虚析构**

3. 拥有纯虚析构函数的类也属于抽象类

# 5 文件操作

程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放

通过**文件可以将数据持久化**

C++中对文件操作需要包含头文件 ==< fstream >==

文件类型分为两种：

1. **文本文件** - 文件以文本的**ASCII码**形式存储在计算机中
    
2. **二进制文件** - 文件以文本的**二进制**形式存储在计算机中，用户一般不能直接读懂它们
    

操作文件的三大类:

1. ofstream：写操作
    
2. ifstream： 读操作
    
3. fstream ： 读写操作

## 5.1文本文件

### 5.1.1写文件

写文件步骤如下：

1. 包含头文件
    
    #include <fstream>
    
2. 创建流对象
    
    ofstream ofs;
    
3. 打开文件
    
    ofs.open("文件路径",**打开方式**);
    
4. 写数据
    
    ofs << "写入的数据";
    
5. 关闭文件
    
    ofs.close();
    

文件**打开方式**：

|打开方式|解释|
|---|---|
|ios::in|为读文件而打开文件|
|ios::out|为写文件而打开文件|
|ios::ate|初始位置：文件尾|
|ios::app|追加方式写文件|
|ios::trunc|如果文件存在先删除，再创建|
|ios::binary|二进制方式|

**注意：** 文件打开方式可以配合使用，利用|操作符

**例如：**用二进制方式写文件 `ios::binary | ios:: out`

总结：

- 文件操作必须包含头文件 fstream
    
- 读文件可以利用 ofstream ，或者fstream类
    
- 打开文件时候需要指定操作文件的路径，以及打开方式
    
- 利用<\<可以向文件中写数据
    
- 操作完毕，要关闭文件

### 5.1.2读文件

读文件与写文件步骤相似，但是读取方式相对于比较多

读文件步骤如下：

1. 包含头文件
    
    #include <fstream>
    
2. 创建流对象
    
    ifstream ifs;
    
3. 打开文件并判断文件是否打开成功
    
    ifs.open("文件路径",打开方式);
    
4. 读数据
    
    四种方式读取
    第一种方式
	char buf[1024] = { 0 };(利用数组，把ifs中的数据全部放到buff中)
	while (ifs >> buf)
	{
		cout << buf << endl;
	}

	第二种(利用数组，然后使用ifs.getline函数，该函数是获取每一行，将其放到buf中)
	char buf[1024] = { 0 };
	while (ifs.getline(buf,sizeof(buf)))
	{
		cout << buf << endl;
	}

	第三种(使用string字符串，然后使用getline函数，此函数是全局的，需要放输入流和字符串)
	string buf;
	while (getline(ifs, buf))
	{
		cout << buf << endl;
	}
	
	第四种(定义一个char类型，把每个字符读取到char类型的字符里面，EOF是判断读没读到文件尾)
	char c;
	while ((c = ifs.get()) != EOF)
	{
		cout << c;
	}
    
5. 关闭文件
    
    ifs.close();

总结：

- 读文件可以利用 ifstream ，或者fstream类
    
- 利用is_open函数可以判断文件是否打开成功
    
- close 关闭文件

## 5.2 二进制文件

以二进制的方式对文件进行读写操作

打开方式要指定为 ==ios::binary==

### 5.2.1 写文件

二进制方式**写文件主要利用流对象调用成员函数write**

函数原型 ：`ostream& write(const char * buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数

例子：

Person p = {"张三"  , 18};
ofs.write((const char *)&p, sizeof(p));

### 5.2.2 读文件

二进制方式读文件主要利用流对象调用成员函数read

函数原型：`istream& read(char *buffer,int len);`

参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数

例子：

	Person p;
	ifs.read((char *)&p, sizeof(p));